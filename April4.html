<html>
	<head>
		<meta charset="utf-8">
	  <title>Sandbox</title>
    <!-- Most the code in this body block is based off of the W3 HTML game tutorial-->
    <script type="text/javascript">
        // Stuff for the canvas which displays the game.
        var myGameArea = {
            canvas : document.createElement("canvas"),
            start : function() {
                this.canvas.width = 1500;
                this.canvas.height = 750;
                // I don't exactly understand how these next two lines work. All I know is that they are important. The W3  HTML tutorial discussed them.
                this.context = this.canvas.getContext("2d");
                document.body.insertBefore(this.canvas, document.body.childNodes[0]);
                // This line determines how often the game updates itself. The 20 signifies 20 milliseconds.
                // The game updates itself by calling the updateGameArea method, whose name is listed as the first param in this line of code.
                this.interval = setInterval(updateGameArea, 20);
                // This keeps track of the x and y coordinates of the mouse.
                window.addEventListener('mousemove', function (e) {myGameArea.x = e.pageX; myGameArea.y = e.pageY;});
            },
            // Erase the previous "frame" of the game so that the new (updated) frame can then be drawn.
            clear : function() {
                this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
            },
            // This is called when the came is lost. The clearInterval lines make the game stop updating.
            stop : function() {
                window.alert("you lost! :(");
                clearInterval(this.interval);
            }
        }



        // This function runs when the page loads (see the onload attribute of body tag)
        function startGame(){
            myGameArea.start();
            // Lava pits- do damage to every player
            obstacles[0] = new obstacle("red", 850, 500, 25, "lava");
            obstacles[1] = new obstacle("red", 650, 320, 15, "lava");
            // Lakes- do damage to large players
            obstacles[2] = new obstacle("blue", 500, 600, 150, "lake");
            obstacles[3] = new obstacle("blue", 100, 100, 225, "lake");
            monsters[0] = new monster(500, 300);
            // Initialize objects in food array
            for(playerCreationCounter = 0; playerCreationCounter < players.length; playerCreationCounter++){
                players[playerCreationCounter] = new player(50, 200, playerCreationCounter);
            }
        }



      // Note- after reviewing the component code, it might seem that it would be more sensible to create a "food" object
      // that extends component. I do not do this because polymporphism is really tricky in JS, it seems simpler to use a
      // slightly more clunky "component" object instead.

      // Second note- after reviwing this document, it might seem that it would be more sensible to create a second "interval"
      // to time the random appearnces of food. However, this is very difficult to do since Javscript is single-threaded.
      // Hence the "intervalCounter" variable and assorted code at the end of updateGame().

      var players = new Array(1);
      var obstacles = new Array(4);
      var monsters = new Array(1);
      var food = new Array(0);

      var startingPlayerRadius = 30;
      var startingMonsterRadius = 55;
      var foodRadius = 5;
      var growthThroughEatingFood = 2000;
      var maxAmountOfFood = 5;
      var obstacleDamage = 100;
      var monsterAndPlayerDamage = 200;

      // This variable keeps track of how many intervals have passed. Every time it reaches 50 (every second) it resets to zero. It is used to make food appear at a different rate than the game updates.
      var intervalCounter = 0;



      function component(paramColor, paramX, paramY, paramRadius){
          this.x = paramX; 
          this.y = paramY;
          this.color = paramColor;
          this.radius = paramRadius;
      }
      


      component.prototype.update = function(){
          ctx = myGameArea.context;
          ctx.fillStyle = this.color;
          // This code draws the sprites- right now they are all just circles.
          // Code inspired by https://www.w3resource.com/javascript-exercises/javascript-drawing-exercise-2.php
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false);
          ctx.fill();
          ctx.lineWidth = 5;
          ctx.strokeStyle = this.color;
          ctx.stroke();
      }



      component.prototype.touchingObstacle = function(){
          for(obsSearchCounter = 0; obsSearchCounter < obstacles.length; obsSearchCounter++){
              // ...compute the distance between the obstacle and player sprite using the pythagorean theorem...
              obstacleDistance = computeDistance(this, obstacles[obsSearchCounter]);
              // ...if the player's sprite overlaps with the obstacle...
              if(obstacleDistance < (this.radius + obstacles[obsSearchCounter].radius)){
                  //...unless the player is touching a lake and they are small...
                  if(obstacles[obsSearchCounter].obstacleType == "lake" && this.radius < 30){/* Do nothing */}
                      // ...shrink the player sprite size.
                  else{
                      return true;
                  }
              }
          }
          return false;
      }



      component.prototype.changeArea = function(amount){
          oldArea = Math.pow(this.radius,2)*Math.PI;
          // This if statement ensures that the program never tries to squrt a negative area
          if((oldArea <= Math.abs(amount)) && (amount < 0)){
              this.radius = .01;
          }
          else{
              this.radius = Math.sqrt((oldArea+amount)/Math.PI);
          }
      }



      function player(paramX, paramY, paramPlayerIndex){
          component.call(this, "green", paramX, paramY, startingPlayerRadius);
          this.playerIndex = paramPlayerIndex;
      }
      player.prototype = Object.create(component.prototype);
      player.prototype.constructor = player;



      function obstacle(paramColor, paramX, paramY, paramRadius, paramObstacleType){
          component.call(this, paramColor, paramX, paramY, paramRadius);
          this.obstacleType = paramObstacleType;
      }
      obstacle.prototype = Object.create(component.prototype);
      obstacle.prototype.constructor = obstacle;



      function foodPiece(paramX, paramY){
          component.call(this, "yellow", paramX, paramY, foodRadius);
      }
      foodPiece.prototype = Object.create(component.prototype);
      foodPiece.prototype.constructor = foodPiece;
      


      function monster(paramSpawnX, paramSpawnY){
          component.call(this, "orange", paramSpawnX, paramSpawnY, startingMonsterRadius);
          this.distances = new Array(players.length);
          this.spawnX = paramSpawnX;
          this.spawnY = paramSpawnY;
      }
      monster.prototype = Object.create(component.prototype);
      monster.prototype.constructor = monster
      monster.prototype.hurtPlayers = function(){
          for(playerToCheck = 0; playerToCheck < this.distances.length; playerToCheck++){
              if(this.distances[playerToCheck] < (this.radius + players[playerToCheck].radius)){
                  players[playerToCheck].changeArea(-200);
              }
          }
      }



      monster.prototype.findClosetPlayer = function(){
          //9999 is aribtraily large distance so first # in distances array will always seem smaller
          var shortestDistance = 9999;
          var closestPlayer = -1;
          for(closestPlayerCounter = 0; closestPlayerCounter < monsters[monsterUpdateCounter].distances.length; closestPlayerCounter++){
              // The if loop below ensures that the monster only chases large players.
              monsters[monsterUpdateCounter].distances[closestPlayerCounter] = computeDistance(monsters[monsterUpdateCounter], players[closestPlayerCounter]);
              if((monsters[monsterUpdateCounter].distances[closestPlayerCounter] < shortestDistance) && (players[closestPlayerCounter].radius < this.radius)){
                  shortestDistance = monsters[monsterUpdateCounter].distances[closestPlayerCounter];
                  closestPlayer = closestPlayerCounter;
              }
          }
          return closestPlayer;
      }



      monster.prototype.changePosition = function(closestPlayer){
          var horizontalDistance;
          var verticalDistance;
          var monsterSpeed = 2;
          var monsterSpeedX;
          var monsterSpeedY;
          if(closestPlayer == -1){
              monsterSpeedX = 0;
              monsterSpeedY = 0;
          }
          else{
              horizontalDistance = players[closestPlayer].x-monsters[monsterUpdateCounter].x;
              verticalDistance = players[closestPlayer].y-monsters[monsterUpdateCounter].y;
              monsterSpeedX = (Math.pow(Math.pow(monsterSpeed,2)/(1+(Math.pow(verticalDistance,2)/Math.pow(horizontalDistance,2))),0.5))/(this.radius/40);
              if(horizontalDistance < 0){
                  monsterSpeedX *= -1;
              }
              monsterSpeedY = monsterSpeedX * verticalDistance/horizontalDistance;
          }
          monsters[monsterUpdateCounter].x = monsters[monsterUpdateCounter].x + monsterSpeedX;
          monsters[monsterUpdateCounter].y = monsters[monsterUpdateCounter].y + monsterSpeedY; 
      }



      monster.prototype.changeArea = function(amount){
          if(amount < 0){
              component.prototype.changeArea.call(this, amount);
          }
          else{
              newRadius = this.radius + Math.sqrt(amount/Math.PI);
              if(newRadius >= startingMonsterRadius){
                  this.radius = startingMonsterRadius;
              }
              else{
                  this.radius = newRadius;
              }
          }
      }



      // This function is called by the setInterval method to update the game.
      function updateGameArea() {
          //If the player gets small enough they "die," stopping the game. Presumably this code will have to be changed once multiplayer functionality is implemented?
          // The code "if(player.radius <= 0)" won't work because of rounding error- sometimes the player has a radius of 0.00000002, for instance.
          if(players[0].radius <= 0.02){
              myGameArea.stop();
          }
          // "else" means "if the player has not died," in other words, "if the game can continue."
          else{
              checkFood();
              moveMonsters();
              movePlayer();
              dealDamage();
              updateIntervalCounter();
              drawNewFrame();
          }
      }



      function getNewRandomCoordinates(spawningObjectRadius){
          while(true){
              potentialX = Math.random()*myGameArea.canvas.width;
              potentialY = Math.random()*myGameArea.canvas.height;
              allOk = true;
              for(obstacleNumber = 0; obstacleNumber < obstacles.length; obstacleNumber++){
                  distance = Math.pow((Math.pow((obstacles[obstacleNumber].x-potentialX),2) + Math.pow((obstacles[obstacleNumber].y-potentialY),2)),0.5);
                  if(distance < (obstacles[obstacleNumber].radius+spawningObjectRadius+5)){
                    allOk = false;
                  }
              }
              if(allOk){
                  return [potentialX, potentialY];
              }
          }
      }



      function computeDistance(object1, object2){
          return Math.pow((Math.pow((object1.x-object2.x), 2) + Math.pow((object1.y-object2.y), 2)), 0.5);
      }



      function checkFood(){
          // WARNING- it might appear that the below system of the while loop, if loops, etc. could be combined into a for loop. Don't do that!!!. That would break the program, since a for loop won't account for the length of food array being decreased once a foodPiece is spliced out of it. So a for loop structure would break the program as soon as the player ate a foodPiece and then the program called tryToEat for the monster and passed in the old food.length-1 that is (after the splicing due to the player's eating) really now food.length and hence pointing to a nonexistent foodPiece.
          foodDeleteCounter = 0;
          while(foodDeleteCounter < food.length){
              for(checkPlayer = 0; checkPlayer < players.length; checkPlayer++){
                  if(foodDeleteCounter >= 0){
                      ateLastFoodInArray = tryToEat(foodDeleteCounter, players[checkPlayer]);
                      if(ateLastFoodInArray){
                          foodDeleteCounter -= 1;
                      }
                  }
              }
              for(checkMonster = 0; checkMonster < monsters.length; checkMonster++){
                  if(foodDeleteCounter > 0){
                      ateLastFoodInArray = tryToEat(foodDeleteCounter, monsters[checkMonster]);
                      if(ateLastFoodInArray){
                          foodDeleteCounter -= 1;
                      }
                  }
              }
              foodDeleteCounter++;
          }
      }



      function moveMonsters(){
          for(monsterUpdateCounter = 0; monsterUpdateCounter < monsters.length; monsterUpdateCounter++){
              if(monsters[monsterUpdateCounter].radius < 0.02){
                  monsters[monsterUpdateCounter] = new monster(monsters[monsterUpdateCounter].spawnX, monsters[monsterUpdateCounter].spawnY);
              }
              else{
                  monsters[monsterUpdateCounter].hurtPlayers();
                  monsters[monsterUpdateCounter].changePosition(monsters[monsterUpdateCounter].findClosetPlayer());
              }                       
          }
      }



      function movePlayer(){
          // I'm not sure why this "if" statement is relevant, but the W3 tutorial included it and the game acts wierd if it is removed.
          // Maybe it tests if the mouse cursor is actually in the canvas?
          if (myGameArea.x && myGameArea.y) {
              // Speed in X-direction is computed by the fraction with (X-distance between mouse cursor and player sprite) in the numerator,
              // and (player-size * some constant).
              // Thus, the player sprite will move faster if the mouse is farther away from it and slower if it is larger.
              speedX = (myGameArea.x - players[0].x)/(players[0].radius/2);
              // Same theory for speed in Y-direction.
              speedY = (myGameArea.y - players[0].y)/(players[0].radius/2);
              // If the player wants to move rightwards && the right extreme of their sprite is touching/beyond the right of the canvas, stop the // rightward movement so they don't go off the canvas.
              if((speedX > 0) && ((players[0].x + players[0].radius) >= myGameArea.canvas.width)){
                  speedX = 0;
              }
              // If the player wants to move leftwards && the left extreme of their sprite is touching/beyond the left of the vancas, stop the
              // leftward movement so they don't go off the canvas.
              if((speedX < 0) && ((players[0].x - players[0].radius) <= 0)){
                  speedX = 0;
              }
              // If the player wants to move upwards && the top of their sprite is touching/beyond the top of the canvas, stop the upward movement so they don't go off the canvas.
              if((speedY > 0) && ((players[0].y + players[0].radius) >= myGameArea.canvas.height)){
                  speedY = 0;
              }
              // If the player wants to move downwards && the bottom of their sprite is touching/beyond the bottom of the canvas, stop the downward movement so they don't go off the screen.
              if((speedY < 0) && ((players[0].y - players[0].radius) <= 0)){
                  speedY = 0;
              }
              players[0].x = players[0].x + speedX;
              players[0].y = players[0].y + speedY; 
          }
      }



      function dealDamage(){
          for(monsterDamageCounter = 0; monsterDamageCounter < monsters.length; monsterDamageCounter++){
              // obstacles hurt monsters
              if(monsters[monsterDamageCounter].touchingObstacle()){
                  monsters[monsterDamageCounter].changeArea(- obstacleDamage);
              }
              // monsters & players hurt each other
              for(monPlayDamageCounter = 0; monPlayDamageCounter < monsters[monsterDamageCounter].distances.length; monPlayDamageCounter++){
                  // if monster is touching a player
                  if(monsters[monsterDamageCounter].distances[monPlayDamageCounter] <= (monsters[monsterDamageCounter].radius + players[monPlayDamageCounter].radius)){
                      //if monster is bigger
                      if(monsters[monsterDamageCounter].radius > players[monPlayDamageCounter].radius){
                          monsters[monsterDamageCounter].changeArea(monsterAndPlayerDamage);
                          players[monPlayDamageCounter].changeArea(- monsterAndPlayerDamage);
                      }
                      else{
                          monsters[monsterDamageCounter].changeArea(- monsterAndPlayerDamage);
                          players[monPlayDamageCounter].changeArea(monsterAndPlayerDamage);
                      }
                  }
              }
          }
          for(playerHurtByObsCounter = 0; playerHurtByObsCounter < players.length; playerHurtByObsCounter++){
              // obstacles hurt player
              if(players[playerHurtByObsCounter].touchingObstacle()){
                  players[playerHurtByObsCounter].changeArea(- obstacleDamage);
              }
              //players hurt each other- make sure to only go through half the combos, eg dont check 2 against 1 after already checking 1 against 2

          }
      }



      function updateIntervalCounter(){
          // If one second has passed since the last piece of food was added...
          if(intervalCounter == 50){
            // Although it looks like the above and below "if" loops can be combined, please do not combine
            // them, because that would slightly break the game logic.
              if(food.length < maxAmountOfFood){
                  //...add a new food to the end of the food array...
                  newCoordinates = getNewRandomCoordinates(foodRadius);
                  var newFood = new foodPiece(newCoordinates[0], newCoordinates[1]);
                  newFood.prototype = Object.create(component.prototype);
                  food.push(newFood);
              }
              // ...reset the interval counter.
              intervalCounter = 0;
          }
          else{
              intervalCounter++;
          }
      }



      function tryToEat(foodNum, potentialEater){
          if(potentialEater)
          distance = computeDistance(potentialEater, food[foodNum]);
          /// if the sprite overlaps with the food
          if(distance <= (potentialEater.radius + foodRadius)){
              potentialEater.changeArea(growthThroughEatingFood);
              // update
              // Remove that piece of food from the food array. The "1" parameter makes its so that only one food element will be spliced.
              food.splice(foodNum, 1);
          }
      }



      function drawNewFrame(){
          myGameArea.clear();
          for(obstacleUpdateCounter = 0; obstacleUpdateCounter < obstacles.length; obstacleUpdateCounter++){
              obstacles[obstacleUpdateCounter].update();
          }
          for(foodUpdateCounter = 0; foodUpdateCounter < food.length; foodUpdateCounter++){
              food[foodUpdateCounter].update();
          }
          for(monsterUpdateCounter = 0; monsterUpdateCounter < monsters.length; monsterUpdateCounter++){
              monsters[monsterUpdateCounter].update();
          }
          for(playerUpdateCounter = 0; playerUpdateCounter < players.length; playerUpdateCounter++){
              players[playerUpdateCounter].update();
          }
      }

    </script>

	</head>

	<body onload ="startGame()">
		
	</body>

</html>