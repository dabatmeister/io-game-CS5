<html>
	<head>
		<meta charset="utf-8">
		<title>Sandbox</title>
<!-- Most the code in this body block is based off of the W3 HTML game tutorial-->
    <script type="text/javascript">
      // Note- after reviewing the component code, it might seem that it would be more sensible to create a "food" object
      // that extends component. I do not do this because polymporphism is really tricky in JS, it seems simpler to use a
      // slightly more clunky "component" object instead.

      // Second note- after reviwing this document, it might seem that it would be more sensible to create a second "interval"
      // to time the random appearnces of food. However, this is very difficult to do since Javscript is single-threaded.
      // Hence the "intervalCounter" variable and assorted code at the end of updateGame().

      var players = new Array(1);
      var obstacles = new Array(4);
      var monsters = new Array(1);
      var food = new Array(10);

      // This variable keeps track of how many intervals have passed. Every time it reaches 50 (every second) it resets to zero.
      // It is used to make food appear at a different rate than the game updates.
      var intervalCounter = 0;

      // This function runs when the page loads (see the onload attribute of body tag)
      function startGame(){
          myGameArea.start();
          // Lava pits- do damage to every player
          obstacles[0] = new obstacle("red", 350, 170, 25, "lava");
          obstacles[1] = new obstacle("red", 650, 320, 15, "lava");
          // Lakes- do damage to large players
          obstacles[2] = new obstacle("blue", 500, 600, 150, "lake");
          obstacles[3] = new obstacle("blue", 100, 100, 225, "lake");
          // Monsters- live in lakes, chase the nearest player
          monsters[0] = new monster(500, 300);
          // Initialize objects in food array
          for(i = 0; i < food.length; i++){
            food[i] = new foodPiece("yellow", Math.random()*myGameArea.canvas.width, Math.random()*myGameArea.canvas.height, i);
          }
          for(i = 0; i < players.length; i++){
             players[i] = new player("green", 50, 200, i);
         }
      }


 
      function component(paramColor, paramX, paramY, paramRadius){
          this.x = paramX; 
          this.y = paramY;
          this.color = paramColor;
          this.radius = paramRadius;
      }
      

      //The update function is called during every time the game updates (right now this happens every 20 milliseconds)
      component.prototype.update = function(){
          ctx = myGameArea.context;
          ctx.fillStyle = this.color;
          // This code draws the sprites- right now they are all just circles.
          // Code inspired by https://www.w3resource.com/javascript-exercises/javascript-drawing-exercise-2.php
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false);
          ctx.fill();
          ctx.lineWidth = 5;
          ctx.strokeStyle = this.color;
          ctx.stroke();
      }

      function player(paramColor, paramX, paramY, paramPlayerIndex){
          component.call(this, paramColor, paramX, paramY, 30);
          this.playerIndex = paramPlayerIndex;
      }
      player.prototype = Object.create(component.prototype);
      player.prototype.constructor = player;



      function obstacle(paramColor, paramX, paramY, paramRadius, paramObstacleType){
          component.call(this, paramColor, paramX, paramY, paramRadius);
          this.obstacleType = paramObstacleType;
      }
      obstacle.prototype = Object.create(component.prototype);
      obstacle.prototype.constructor = obstacle;



      function foodPiece(paramColor, paramX, paramY, paramFoodIndex){
          component.call(this, paramColor, paramX, paramY, 5);
          this.foodIndex = paramFoodIndex;
          this.visibility = true;
      }
      foodPiece.prototype = Object.create(component.prototype);
      foodPiece.prototype.constructor = foodPiece;
      


      function monster(paramX, paramY){
          component.call(this, "orange", paramX, paramY, 40);
          this.distances = new Array(players.length);
     
      }
      monster.prototype = Object.create(component.prototype);
      monster.prototype.constructor = monster;




      // Stuff for the canvas which displays the game.
      var myGameArea = {
          canvas : document.createElement("canvas"),
          start : function() {
              this.canvas.width = 1500;
              this.canvas.height = 750;
              // I don't exactly understand how these next two lines work. All I know is that they are important. The W3 HTML tutorial discussed them.
              this.context = this.canvas.getContext("2d");
              document.body.insertBefore(this.canvas, document.body.childNodes[0]);
              // This line determines how often the game updates itself. The 20 signifies 20 milliseconds.
              // The game updates itself by calling the updateGameArea method, whose name is listed as the first param in this line of code.
              this.interval = setInterval(updateGameArea, 20);
              // This keeps track of the x and y coordinates of the mouse.
              window.addEventListener('mousemove', function (e) {myGameArea.x = e.pageX; myGameArea.y = e.pageY;});
          },
          // Erase the previous "frame" of the game so that the new (updated) frame can then be drawn.
          clear : function() {
              this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
          },
          // This is called when the came is lost. The clearInterval lines make the game stop updating.
          stop : function() {
            window.alert("you lost! :(");
            clearInterval(this.interval);
          }
      }


      // This function is called by the setInterval method to update the game.
      function updateGameArea() {
          //If the player gets small enough they "die," stopping the game. Presumably this code will have to be changed once multiplayer functionality is implemented?
          // The code "if(player.radius <= 0)" won't work because of rounding error- sometimes the player has a radius of 0.00000002, for instance.
          if(players[0].radius <= 0.02){
              myGameArea.stop();
          }
          // "else" means "if the player has not died," in other words, "if the game can continue."
          else{
              // Delete the old frame of the game.
              myGameArea.clear();
              // Update all of the obstacles.
              for(i = 0; i < obstacles.length; i++){
                  obstacles[i].update();
              };
              // Update all of the food.
              for(i = 0; i < food.length; i++){
                  if(food[i].visibility){
                      food[i].update();
                  }
              };
              for(i = 0; i < monsters.length; i++){
                  // 9999 is aribtraily large distance so first # in distances array will always seem smaller
                  for(ii = 0; ii < monsters[i].distances.length; ii++){
                      if(monsters[i].distances[ii] < (monsters[i].radius + players[ii].radius)){
                          oldArea = Math.pow(players[ii].radius,2)*Math.PI
                          if(oldArea < 101){
                            players[ii].radius = 0.01;
                          }
                          else{
                            players[ii].radius = Math.sqrt((oldArea-100)/Math.PI);
                          }
                      }
                  }
                  var shortestDistance = 9999;
                  var closestPlayer = -1;
                  for(ii = 0; ii < monsters[i].distances.length; ii++){
                      // The if loop below ensures that the monster only chases large players.
                      monsters[i].distances[ii] = Math.pow((Math.pow((monsters[i].x-players[ii].x),2) + Math.pow((monsters[i].y-players[ii].y),2)),0.5);
                      if((monsters[i].distances[ii] < shortestDistance) && (players[ii].radius > 45)){
                          shortestDistance = monsters[i].distances[ii];
                          closestPlayer = ii;
                      }
                  }
                  var horizontalDistance;
                  var verticalDistance;
                  var monsterSpeed = 2;
                  var monsterSpeedX;
                  var monsterSpeedY;

                  if(closestPlayer == -1){
                      monsterSpeedX = 0;
                      monsterSpeedY = 0;
                  }
                  else{
                      horizontalDistance = players[closestPlayer].x-monsters[i].x;
                      verticalDistance = players[closestPlayer].y-monsters[i].y;
                      monsterSpeedX = Math.pow(Math.pow(monsterSpeed,2)/(1+(Math.pow(verticalDistance,2)/Math.pow(horizontalDistance,2))),0.5);
                      if(horizontalDistance < 0){
                          monsterSpeedX *= -1;
                      }
                      monsterSpeedY = monsterSpeedX * verticalDistance/horizontalDistance;
                  }
                  

                  monsters[i].x = monsters[i].x + monsterSpeedX;
                  monsters[i].y = monsters[i].y + monsterSpeedY;
                  monsters[i].update();
               
              }; 
              // I'm not sure why this "if" statement is relevant, but the W3 tutorial included it and the game acts wierd if it is removed.
              // Maybe it tests if the mouse cursor is actually in the canvas?
              if (myGameArea.x && myGameArea.y) {
                  // Speed in X-direction is computed by the fraction with (X-distance between mouse cursor and player sprite) in the numerator,
                  // and (player-size * some constant).
                  // Thus, the player sprite will move faster if the mouse is farther away from it and slower if it is larger.
                  speedX = (myGameArea.x - players[0].x)/(players[0].radius/2);
                  // Same theory for speed in Y-direction.
                  speedY = (myGameArea.y - players[0].y)/(players[0].radius/2);
                  
                  // If the player wants to move rightwards && the right extreme of their sprite is touching/beyond the right of the canvas, stop the // rightward movement so they don't go off the canvas.
                  if((speedX > 0) && ((players[0].x + players[0].radius) >= myGameArea.canvas.width)){
                      speedX = 0;
                  };
                  // If the player wants to move leftwards && the left extreme of their sprite is touching/beyond the left of the vancas, stop the
                  // leftward movement so they don't go off the canvas.
                  if((speedX < 0) && ((players[0].x - players[0].radius) <= 0)){
                      speedX = 0;
                  };
                  // If the player wants to move upwards && the top of their sprite is touching/beyond the top of the canvas, stop the upward movement so they don't go off the canvas.
                  if((speedY > 0) && ((players[0].y + players[0].radius) >= myGameArea.canvas.height)){
                      speedY = 0;
                  };
                  // If the player wants to move downwards && the bottom of their sprite is touching/beyond the bottom of the canvas, stop the downward movement so they don't go off the screen.
                  if((speedY < 0) && ((players[0].y - players[0].radius) <= 0)){
                      speedY = 0;
                  };
                  players[0].x = players[0].x + speedX;
                  players[0].y = players[0].y + speedY; 
              };
              // For each obstacle...
              for(i = 0; i < obstacles.length; i++){
                   // ...compute the distance between the obstacle and player sprite using the pythagorean theorem...
                  obstacleDistance = Math.pow(Math.pow(players[0].x-obstacles[i].x, 2) + Math.pow(players[0].y-obstacles[i].y, 2), 0.5);
                  // ...if the player's sprite overlaps with the obstacle...
                  if(obstacleDistance < (players[0].radius + obstacles[i].radius)){
                      //...unless the player is touching a lake and they are small...
                      if(obstacles[i].obstacleType == "lake" && players[0].radius < 30){/* Do nothing */}
                      // ...shrink the player sprite size.
                      else{
                          players[0].radius-= 0.3;
                      };
                  };
              };
              // For each piece of food...
              for(i = 0; i < food.length; i++){
                   // ...compute the distance between the obstacle and player sprite using the pythagorean theorem...
                  fDistance = Math.pow(Math.pow(players[0].x-food[i].x, 2) + Math.pow(players[0].y-food[i].y, 2), 0.5);
                  // ... if the player's sprite overlaps with the food and the food is visible (not eaten)...
                 
                  if((fDistance < (players[0].radius + food[i].radius)) && food[i].visibility == true){
                      // grow the sprite by a fixed area each time
                      oldArea = Math.pow(players[0].radius,2)*Math.PI
                      players[0].radius = Math.sqrt((oldArea+2000)/Math.PI);
                      // Make the food dissapear
                      food[i].visible = false;
                      // Remove that piece of food from the food array.
                      // The "1" parameter makes its so that only one food element will be spliced- without it,
                      // every time a food is eaten all foods that were added subsequently to the eaten foor will be deleted as well.
                      food.splice(i, 1);
                  };
              };
              // If one second has passed since the last piece of food was added...
              if(intervalCounter == 50){
                  //...add a new food to the end of the food array...
                  var newFood = new foodPiece("yellow", Math.random()*myGameArea.canvas.width, Math.random()*myGameArea.canvas.height, food.length)
                  newFood.prototype = Object.create(component.prototype);
                  food.push(newFood);
                  // ...reset the interval counter.
                  intervalCounter = 0;
              }
              else{
                intervalCounter++;
              };
          };
          players[0].update();
      };

    </script>

	</head>

	<body onload ="startGame()">
		
	</body>

</html>