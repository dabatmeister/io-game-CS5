<html>
	<head>
		<meta charset="utf-8">
	  <title>Sandbox</title>
    <!-- Most the code in this body block is based off of the W3 HTML game tutorial-->
    <script type="text/javascript">
        // Stuff for the canvas which displays the game.
        var myGameArea = {
            canvas : document.createElement("canvas"),
            start : function() {
                this.canvas.width = 1500;
                this.canvas.height = 750;
                // I don't exactly understand how these next two lines work. All I know is that they are important. The W3  HTML tutorial discussed them.
                this.context = this.canvas.getContext("2d");
                document.body.insertBefore(this.canvas, document.body.childNodes[0]);
                // This line determines how often the game updates itself. The 20 signifies 20 milliseconds.
                // The game updates itself by calling the updateGameArea method, whose name is listed as the first param in this line of code.
                this.interval = setInterval(updateGameArea, 20);
                // This keeps track of the x and y coordinates of the mouse.
                window.addEventListener('mousemove', function (e) {myGameArea.x = e.pageX; myGameArea.y = e.pageY;});
            },
            // Erase the previous "frame" of the game so that the new (updated) frame can then be drawn.
            clear : function() {
                this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
            },
            // This is called when the came is lost. The clearInterval lines make the game stop updating.
            stop : function() {
                window.alert("you lost! :(");
                clearInterval(this.interval);
            }
        }



        // This function runs when the page loads (see the onload attribute of body tag)
        function startGame(){
            myGameArea.start();
            // Lava pits- do damage to every player
            obstacles[0] = new obstacle("red", 850, 500, 25, "lava");
            obstacles[1] = new obstacle("red", 650, 320, 15, "lava");
            // Lakes- do damage to large players
            obstacles[2] = new obstacle("blue", 500, 600, 150, "lake");
            obstacles[3] = new obstacle("blue", 100, 100, 225, "lake");
            monsters[0] = new monster(500, 300);
            // Initialize objects in food array
            for(playerCreationCounter = 0; playerCreationCounter < players.length; playerCreationCounter++){
                players[playerCreationCounter] = new player("green", 50, 200, playerCreationCounter);
            }
        }



      // Note- after reviewing the component code, it might seem that it would be more sensible to create a "food" object
      // that extends component. I do not do this because polymporphism is really tricky in JS, it seems simpler to use a
      // slightly more clunky "component" object instead.

      // Second note- after reviwing this document, it might seem that it would be more sensible to create a second "interval"
      // to time the random appearnces of food. However, this is very difficult to do since Javscript is single-threaded.
      // Hence the "intervalCounter" variable and assorted code at the end of updateGame().

      var players = new Array(1);
      var obstacles = new Array(4);
      var monsters = new Array(1);
      var food = new Array(0);

      var startingPlayerRadius = 30;
      var startingMonsterRadius = 40;
      var foodRadius = 5;

      // This variable keeps track of how many intervals have passed. Every time it reaches 50 (every second) it resets to zero. It is used to make food appear at a different rate than the game updates.
      var intervalCounter = 0;



      function component(paramColor, paramX, paramY, paramRadius){
          this.x = paramX; 
          this.y = paramY;
          this.color = paramColor;
          this.radius = paramRadius;
      }
      


      component.prototype.update = function(){
          ctx = myGameArea.context;
          ctx.fillStyle = this.color;
          // This code draws the sprites- right now they are all just circles.
          // Code inspired by https://www.w3resource.com/javascript-exercises/javascript-drawing-exercise-2.php
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false);
          ctx.fill();
          ctx.lineWidth = 5;
          ctx.strokeStyle = this.color;
          ctx.stroke();
      }



      function player(paramColor, paramX, paramY, paramPlayerIndex){
          component.call(this, paramColor, paramX, paramY, startingPlayerRadius);
          this.playerIndex = paramPlayerIndex;
      }
      player.prototype = Object.create(component.prototype);
      player.prototype.constructor = player;



      function obstacle(paramColor, paramX, paramY, paramRadius, paramObstacleType){
          component.call(this, paramColor, paramX, paramY, paramRadius);
          this.obstacleType = paramObstacleType;
      }
      obstacle.prototype = Object.create(component.prototype);
      obstacle.prototype.constructor = obstacle;



      function foodPiece(paramColor, paramX, paramY, paramFoodIndex){
          component.call(this, paramColor, paramX, paramY, foodRadius);
          this.foodIndex = paramFoodIndex;
      }
      foodPiece.prototype = Object.create(component.prototype);
      foodPiece.prototype.constructor = foodPiece;
      


      function monster(paramSpawnX, paramSpawnY){
          component.call(this, "orange", paramSpawnX, paramSpawnY, startingMonsterRadius);
          this.distances = new Array(players.length);
          this.spawnX = paramSpawnX;
          this.spawnY = paramSpawnY;
      }
      monster.prototype = Object.create(component.prototype);
      monster.prototype.constructor = monster
      monster.prototype.hurtPlayers = function(){
          for(playerToCheck = 0; playerToCheck < this.distances.length; playerToCheck++){
              if(this.distances[playerToCheck] < (this.radius + players[playerToCheck].radius)){
                  changeArea(players[playerToCheck], -200);
              }
          }
      }
      monster.prototype.findClosetPlayer = function(){
          //9999 is aribtraily large distance so first # in distances array will always seem smaller
          var shortestDistance = 9999;
          var closestPlayer = -1;
          for(closestPlayerCounter = 0; closestPlayerCounter < monsters[monsterUpdateCounter].distances.length; closestPlayerCounter++){
              // The if loop below ensures that the monster only chases large players.
              monsters[monsterUpdateCounter].distances[closestPlayerCounter] = computeDistance(monsters[monsterUpdateCounter], players[closestPlayerCounter]);
              if((monsters[monsterUpdateCounter].distances[closestPlayerCounter] < shortestDistance) && (players[closestPlayerCounter].radius > 45)){
                  shortestDistance = monsters[monsterUpdateCounter].distances[closestPlayerCounter];
                  closestPlayer = closestPlayerCounter;
              }
          }
          return closestPlayer;
      }
      monster.prototype.changePosition = function(closestPlayer){
          var horizontalDistance;
          var verticalDistance;
          var monsterSpeed = 2;
          var monsterSpeedX;
          var monsterSpeedY;
          if(closestPlayer == -1){
              monsterSpeedX = 0;
              monsterSpeedY = 0;
          }
          else{
              horizontalDistance = players[closestPlayer].x-monsters[monsterUpdateCounter].x;
              verticalDistance = players[closestPlayer].y-monsters[monsterUpdateCounter].y;
              monsterSpeedX = Math.pow(Math.pow(monsterSpeed,2)/(1+(Math.pow(verticalDistance,2)/Math.pow(horizontalDistance,2))),0.5);
              if(horizontalDistance < 0){
                  monsterSpeedX *= -1;
              }
              monsterSpeedY = monsterSpeedX * verticalDistance/horizontalDistance;
          }
          monsters[monsterUpdateCounter].x = monsters[monsterUpdateCounter].x + monsterSpeedX;
          monsters[monsterUpdateCounter].y = monsters[monsterUpdateCounter].y + monsterSpeedY; 
      }



      // This function is called by the setInterval method to update the game.
      function updateGameArea() {
          //If the player gets small enough they "die," stopping the game. Presumably this code will have to be changed once multiplayer functionality is implemented?
          // The code "if(player.radius <= 0)" won't work because of rounding error- sometimes the player has a radius of 0.00000002, for instance.
          if(players[0].radius <= 0.02){
              myGameArea.stop();
          }
          // "else" means "if the player has not died," in other words, "if the game can continue."
          else{
              checkFood();
              moveMonsters();
              movePlayer();
              if(touchingObstacle(players[0])){
                  changeArea(players[0], -130);
              }
              updateIntervalCounter();
              drawNewFrame();
          }
      }



      function touchingObstacle(input){
          for(obstacleSearchingCounter = 0; obstacleSearchingCounter < obstacles.length; obstacleSearchingCounter++){
              // ...compute the distance between the obstacle and player sprite using the pythagorean theorem...
              obstacleDistance = computeDistance(input, obstacles[obstacleSearchingCounter]);
              // ...if the player's sprite overlaps with the obstacle...
              if(obstacleDistance < (input.radius + obstacles[obstacleSearchingCounter].radius)){
                  //...unless the player is touching a lake and they are small...
                  if(obstacles[obstacleSearchingCounter].obstacleType == "lake" && input.radius < 30){/* Do nothing */}
                      // ...shrink the player sprite size.
                  else{
                      return true;
                  }
              }
          }
          return false;
      }



      function getNewRandomCoordinates(spawningObjectRadius){
          while(true){
              potentialX = Math.random()*myGameArea.canvas.width;
              potentialY = Math.random()*myGameArea.canvas.height;
              allOk = true;
              for(obstacleNumber = 0; obstacleNumber < obstacles.length; obstacleNumber++){
                  distance = Math.pow((Math.pow((obstacles[obstacleNumber].x-potentialX),2) + Math.pow((obstacles[obstacleNumber].y-potentialY),2)),0.5);
                  if(distance < (obstacles[obstacleNumber].radius+spawningObjectRadius+5)){
                    allOk = false;
                   // alert(allOk);
                  }
              }
              if(allOk){
                  return [potentialX, potentialY];
              }
          }
      }



      function computeDistance(object1, object2){
          return Math.pow((Math.pow((object1.x-object2.x), 2) + Math.pow((object1.y-object2.y), 2)), 0.5);
      }



      function changeArea(object, amount){
          oldArea = Math.pow(object.radius,2)*Math.PI;
          // This if statement ensures that the program never tries to squrt a negative area
          if((oldArea <= Math.abs(amount)) && (amount < 0)){
              object.radius = .01;
          }
          else{
              object.radius = Math.sqrt((oldArea+amount)/Math.PI);
          }
      }



      function checkFood(){
          for(foodDeleteCounter = 0; foodDeleteCounter < food.length; foodDeleteCounter++){
              fDistance = computeDistance(players[0], food[foodDeleteCounter]);
              // ... if the player's sprite overlaps with the food and the food is visible (not eaten)...
              if(fDistance < (players[0].radius + food[foodDeleteCounter].radius)){
                  // grow the sprite by a fixed area each time
                  changeArea(players[0], 2000);
                  // Remove that piece of food from the food array. The "1" parameter makes its so that only one food element will be spliced.
                  food.splice(foodDeleteCounter, 1);
              }
          }
      }



      function moveMonsters(){
          for(monsterUpdateCounter = 0; monsterUpdateCounter < monsters.length; monsterUpdateCounter++){
              if(monsters[monsterUpdateCounter].radius < 0.02){
                  monsters[monsterUpdateCounter] = new monster(monsters[monsterUpdateCounter].spawnX, monsters[monsterUpdateCounter].spawnY);
              }
              else{
                  monsters[monsterUpdateCounter].hurtPlayers();
                  monsters[monsterUpdateCounter].changePosition(monsters[monsterUpdateCounter].findClosetPlayer());
                  if(touchingObstacle(monsters[monsterUpdateCounter])){
                      changeArea(monsters[monsterUpdateCounter], -50);
                  }
              }                       
          }
      }



      function movePlayer(){
          // I'm not sure why this "if" statement is relevant, but the W3 tutorial included it and the game acts wierd if it is removed.
          // Maybe it tests if the mouse cursor is actually in the canvas?
          if (myGameArea.x && myGameArea.y) {
              // Speed in X-direction is computed by the fraction with (X-distance between mouse cursor and player sprite) in the numerator,
              // and (player-size * some constant).
              // Thus, the player sprite will move faster if the mouse is farther away from it and slower if it is larger.
              speedX = (myGameArea.x - players[0].x)/(players[0].radius/2);
              // Same theory for speed in Y-direction.
              speedY = (myGameArea.y - players[0].y)/(players[0].radius/2);
              // If the player wants to move rightwards && the right extreme of their sprite is touching/beyond the right of the canvas, stop the // rightward movement so they don't go off the canvas.
              if((speedX > 0) && ((players[0].x + players[0].radius) >= myGameArea.canvas.width)){
                  speedX = 0;
              }
              // If the player wants to move leftwards && the left extreme of their sprite is touching/beyond the left of the vancas, stop the
              // leftward movement so they don't go off the canvas.
              if((speedX < 0) && ((players[0].x - players[0].radius) <= 0)){
                  speedX = 0;
              }
              // If the player wants to move upwards && the top of their sprite is touching/beyond the top of the canvas, stop the upward movement so they don't go off the canvas.
              if((speedY > 0) && ((players[0].y + players[0].radius) >= myGameArea.canvas.height)){
                  speedY = 0;
              }
              // If the player wants to move downwards && the bottom of their sprite is touching/beyond the bottom of the canvas, stop the downward movement so they don't go off the screen.
              if((speedY < 0) && ((players[0].y - players[0].radius) <= 0)){
                  speedY = 0;
              }
              players[0].x = players[0].x + speedX;
              players[0].y = players[0].y + speedY; 
          }
      }



      function updateIntervalCounter(){
          // If one second has passed since the last piece of food was added...
          if(intervalCounter == 40){
              //...add a new food to the end of the food array...
              newCoordinates = getNewRandomCoordinates(foodRadius);
              var newFood = new foodPiece("yellow", newCoordinates[0], newCoordinates[1], food.length);
              newFood.prototype = Object.create(component.prototype);
              food.push(newFood);
              // ...reset the interval counter.
              intervalCounter = 0;
          }
          else{
              intervalCounter++;
          }
      }



      function drawNewFrame(){
          myGameArea.clear();
          for(obstacleUpdateCounter = 0; obstacleUpdateCounter < obstacles.length; obstacleUpdateCounter++){
              obstacles[obstacleUpdateCounter].update();
          }
          for(foodUpdateCounter = 0; foodUpdateCounter < food.length; foodUpdateCounter++){
              food[foodUpdateCounter].update();
          }
          for(monsterUpdateCounter = 0; monsterUpdateCounter < monsters.length; monsterUpdateCounter++){
              monsters[monsterUpdateCounter].update();
          }
          for(playerUpdateCounter = 0; playerUpdateCounter < player.length; playerUpdateCounter++){
              players[playerUpdateCounter].update();
          }

      }

    </script>

	</head>

	<body onload ="startGame()">
		
	</body>

</html>