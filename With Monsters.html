<html>
  <head>
	<meta charset="utf-8">
	<title>24 April 2018</title>
	<!-- Most the code in this body block is based off of the W3 HTML game tutorial-->
	<script type="text/javascript">
		// Stuff for the canvas which displays the game.
		var myGameArea = {
			canvas : document.createElement("canvas"),
			start : function() {
				this.canvas.width = window.innerWidth - 16;
				this.canvas.height = window.innerHeight - 16;
				// I don't exactly understand how these next two lines work. All I know is that they are important. The W3  HTML tutorial discussed them.
				this.context = this.canvas.getContext("2d");
				document.body.insertBefore(this.canvas, document.body.childNodes[0]);
				// This line determines how often the game updates itself. The 20 signifies 20 milliseconds.
				// The game updates itself by calling the updateGameArea method, whose name is listed as the first param in this line of code.
				this.interval = setInterval(updateGameArea, 8.3);
				// This keeps track of the x and y coordinates of the mouse.
				window.addEventListener('mousemove', function (e) {myGameArea.x = e.pageX; myGameArea.y = e.pageY;});
			},
			// Erase the previous "frame" of the game so that the new (updated) frame can then be drawn.
			clear : function() {
				this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
			},
			// This is called when the came is lost. The clearInterval lines make the game stop updating.
			stop : function() {
				window.alert("you lost! :(");
				clearInterval(this.interval);
			}
		}



		// This function runs when the page loads (see the onload attribute of body tag)
		function startGame(){
			myGameArea.start();
			// Lava pits- do damage to every player
			obstacles[0] = new obstacle("red", 850, 500, 25, "lava");
			obstacles[1] = new obstacle("red", 650, 320, 15, "lava");
			// Lakes- do damage to large players
			obstacles[2] = new obstacle("blue", 500, 600, 150, "lake");
			obstacles[3] = new obstacle("blue", 100, 100, 225, "lake");
			monsters[0] = new monster(500, 300);
			// Initialize objects in food array
			for(playerCreationCounter = 0; playerCreationCounter < players.length; playerCreationCounter++)
			{
				players[playerCreationCounter] = new player(50, 200, playerCreationCounter);
			}
		}



	  // Note- after reviewing the component code, it might seem that it would be more sensible to create a "food" object
	  // that extends component. I do not do this because polymporphism is really tricky in JS, it seems simpler to use a
	  // slightly more clunky "component" object instead.

	  // Second note- after reviwing this document, it might seem that it would be more sensible to create a second "interval"
	  // to time the random appearnces of food. However, this is very difficult to do since Javscript is single-threaded.
	  // Hence the "intervalCounter" variable and assorted code at the end of updateGame().

	  var players = new Array(1);
	  var obstacles = new Array(4);
	  var monsters = new Array(1);
	  var food = new Array(0);

	  var worldWidth = 50000;
	  var worldHeight = 50000;

	  var topCornerX = 0; 
	  var topCornerY = 0;

	  var startingPlayerRadius = 30;
	  var maxAndStartingMonsterRadius = 55;
	  var foodRadius = 5;
	  var growthThroughEatingFood = 2000;
	  var maxAmountOfFood = 5;
	  var obstacleDamage = 100;
	  var monsterAndPlayerDamage = 200;

	  // This variable keeps track of how many intervals have passed. Every time it reaches 50 (every second) it resets to zero. It is used to make food appear at a different rate than the game updates.
	  var intervalCounter = 0;



	  function component(paramColor, paramX, paramY, paramRadius){
		  this.x = paramX; 
		  this.y = paramY;
		  this.color = paramColor;
		  this.radius = paramRadius;
	  }
	  


	  component.prototype.update = function(){
		  ctx = myGameArea.context;
		  ctx.fillStyle = this.color;
		  // This code draws the sprites- right now they are all just circles.
		  // Code inspired by https://www.w3resource.com/javascript-exercises/javascript-drawing-exercise-2.php
		  ctx.beginPath();
		  ctx.arc(this.x - topCornerX, this.y - topCornerY, this.radius, 0, 2 * Math.PI, false);
		  ctx.fill();
		  ctx.lineWidth = 5;
		  ctx.strokeStyle = this.color;
		  ctx.stroke();
	  }



	  component.prototype.touchingObstacle = function(){
		  for(let potentialObstacle of obstacles){
			  // ...compute the distance between the obstacle and player sprite using the pythagorean theorem...
			  obstacleDistance = computeDistance(this, potentialObstacle);
			  // ...if the player's sprite overlaps with the obstacle...
			  if(obstacleDistance < (this.radius + potentialObstacle.radius + 6)){
				  //...unless the player is touching a lake and they are small...
				  if(potentialObstacle.obstacleType == "lake" && this.radius < 30){/* Do nothing */}
					  // ...shrink the player sprite size.
				  else{
					  return true;
				  }
			  }
		  }
		  return false;
	  }



	  component.prototype.changeArea = function(amount){
		  oldArea = Math.pow(this.radius,2)*Math.PI;
		  // This if statement ensures that the program never tries to squrt a negative area
		  if((oldArea <= Math.abs(amount)) && (amount < 0)){
			  this.radius = .01;
		  }
		  else{
			  this.radius = Math.sqrt((oldArea+amount)/Math.PI);
		  }
	  }



	  function player(paramX, paramY, paramPlayerIndex){
		  component.call(this, "green", paramX, paramY, startingPlayerRadius);
		  this.playerIndex = paramPlayerIndex;
	  }
	  player.prototype = Object.create(component.prototype);
	  player.prototype.constructor = player;



	  function obstacle(paramColor, paramX, paramY, paramRadius, paramObstacleType){
		  component.call(this, paramColor, paramX, paramY, paramRadius);
		  this.obstacleType = paramObstacleType;
	  }
	  obstacle.prototype = Object.create(component.prototype);
	  obstacle.prototype.constructor = obstacle;



	  function foodPiece(paramX, paramY){
		  component.call(this, "yellow", paramX, paramY, foodRadius);
	  }
	  foodPiece.prototype = Object.create(component.prototype);
	  foodPiece.prototype.constructor = foodPiece;
	  


	  function monster(paramSpawnX, paramSpawnY){
		  component.call(this, "orange", paramSpawnX, paramSpawnY, maxAndStartingMonsterRadius);
		  this.distances = new Array(players.length);
		  this.spawnX = paramSpawnX;
		  this.spawnY = paramSpawnY;
	  }
	  monster.prototype = Object.create(component.prototype);
	  monster.prototype.constructor = monster
	  monster.prototype.hurtPlayers = function(){
		  for(playerToCheck = 0; playerToCheck < this.distances.length; playerToCheck++){
			  if(this.distances[playerToCheck] < (this.radius + players[playerToCheck].radius)){
				  players[playerToCheck].changeArea(-200);
			  }
		  }
	  }



	  monster.prototype.findClosetPlayer = function(){
		  //9999 is aribtraily large distance so first # in distances array will always seem smaller
		  var shortestDistance = 9999;
		  var closestPlayer = -1;
		  for(closestPlayerCounter = 0; closestPlayerCounter < this.distances.length; closestPlayerCounter++){
			  // The if loop below ensures that the monster only chases large players.
			  this.distances[closestPlayerCounter] = computeDistance(this, players[closestPlayerCounter]);
			  if((this.distances[closestPlayerCounter] < shortestDistance) && (players[closestPlayerCounter].radius < this.radius)){
				  shortestDistance = this.distances[closestPlayerCounter];
				  closestPlayer = closestPlayerCounter;
			  }
		  }
		  return closestPlayer;
	  }



	  monster.prototype.changePosition = function(closestPlayer){
		  var horizontalDistance;
		  var verticalDistance;
		  var monsterSpeed = 2;
		  var monsterSpeedX;
		  var monsterSpeedY;
		  if(closestPlayer == -1){
			  monsterSpeedX = 0;
			  monsterSpeedY = 0;
		  }
		  else{
			  horizontalDistance = players[closestPlayer].x-this.x;
			  verticalDistance = players[closestPlayer].y-this.y;
			  monsterSpeedX = (Math.pow(Math.pow(monsterSpeed,2)/(1+(Math.pow(verticalDistance,2)/Math.pow(horizontalDistance,2))),0.5))/(this.radius/40);
			  if(horizontalDistance < 0){
				  monsterSpeedX *= -1;
			  }
			  monsterSpeedY = monsterSpeedX * verticalDistance/horizontalDistance;
		  }
		  this.x = this.x + monsterSpeedX;
		  this.y = this.y + monsterSpeedY; 
	  }



	  monster.prototype.changeArea = function(amount){
		  if(amount < 0){
			  component.prototype.changeArea.call(this, amount);
		  }
		  else{
			  newRadius = this.radius + Math.sqrt(amount/Math.PI);
			  if(newRadius >= maxAndStartingMonsterRadius){
				  this.radius = maxAndStartingMonsterRadius;
			  }
			  else{
				  this.radius = newRadius;
			  }
		  }
	  }



	  // This function is called by the setInterval method to update the game.
	  function updateGameArea() {
		  //If the player gets small enough they "die," stopping the game. Presumably this code will have to be changed once multiplayer functionality is implemented?
		  // The code "if(player.radius <= 0)" won't work because of rounding error- sometimes the player has a radius of 0.00000002, for instance.
		  if(players[0].radius <= 0.02){
			  myGameArea.stop();
		  }
		  // "else" means "if the player has not died," in other words, "if the game can continue."
		  else{
			  checkFood();
			  // moveMonsters();
			  movePlayer();
			  dealDamage();
			  updateIntervalCounter();
			  drawNewFrame();
		  }
	  }



	  function getNewRandomCoordinates(spawningObjectRadius){
		  while(true){
			  // can i change this to be the world contraints instead of the canvas constraints? do i even want that because in theory i only want things to randomly
			  // spawn on the screen that i'm not dealing with the entire world... ask the team on Thursday
			  potentialX = Math.random()*myGameArea.canvas.width;
			  potentialY = Math.random()*myGameArea.canvas.height;
			  allOk = true;
			  for(let blockingObstacle of obstacles){
				  distance = Math.pow((Math.pow((blockingObstacle.x-potentialX),2) + Math.pow((blockingObstacle.y-potentialY),2)),0.5);
				  if(distance < (blockingObstacle.radius+spawningObjectRadius+5)){
					allOk = false;
				  }
			  }
			  if(allOk){
				  return [potentialX, potentialY];
			  }
		  }
	  }



	  function computeDistance(object1, object2){
		  return Math.pow((Math.pow((object1.x-object2.x), 2) + Math.pow((object1.y-object2.y), 2)), 0.5);
	  }



	  function checkFood(){
		  foodDeleteCounter = 0;
		  while(foodDeleteCounter < food.length){
			  for(let checkPlayer of players){
				  foodDeleteCounter = tryToEat(checkPlayer, foodDeleteCounter);
			  }
			  for(let checkMonster of monsters){
				  //if monsters are already max size/close to max size, this if statement
				  //prevents them from eating the food.
				  if(checkMonster.radius < (maxAndStartingMonsterRadius - 2)){
					  foodDeleteCounter = tryToEat(checkMonster, foodDeleteCounter);
				  }
			  }
			  foodDeleteCounter++;
		  }
	  }



	  function moveMonsters(){
		  for(let monsterToMove of monsters){
			  if(monsterToMove.radius < 0.02){
				  monsters[0] = new monster(monsterToMove.spawnX, monsterToMove.spawnY);
			  }
			  else{
				  monsterToMove.hurtPlayers();
				  monsterToMove.changePosition(monsterToMove.findClosetPlayer());
			  }                       
		  }
	  }



	  function movePlayer(){
		  // I'm not sure why this "if" statement is relevant, but the W3 tutorial included it and the game acts wierd if it is removed.
		  // Maybe it tests if the mouse cursor is actually in the canvas?
		  if (myGameArea.x && myGameArea.y) {
			  // Speed in X-direction is computed by the fraction with (X-distance between mouse cursor and player sprite) in the numerator,
			  // and (player-size * some constant).
			  // Thus, the player sprite will move faster if the mouse is farther away from it and slower if it is larger.
			  speedX = ((myGameArea.x - myGameArea.canvas.width/2)/(players[0].radius/2))/4;
			  // Same theory for speed in Y-direction.
			  speedY = ((myGameArea.y - myGameArea.canvas.height/2)/(players[0].radius/2))/4;

			  // console.log("coors: (" + myGameArea.x + ", " + myGameArea.y + ")");

			  // console.log("speed: " + speed);

			  console.log("player coor: (" + players[0].x + ", " + players[0].y + ")"); //" mouse coor: (" + myGameArea.x + ", " + myGameArea.y + ")");
			  
			  // console.log("speedX:" + speedX + " speedY: " + speedY);

			  // If the player wants to move rightwards && the right extreme of their sprite is touching/beyond the right of the canvas, stop the // rightward movement so they don't go off the canvas.

			  if((speedX > 0) && ((players[0].x + players[0].radius) >= worldWidth)){
				  speedX = 0;
				  // myGameArea.canvas.width = topCornerX + myGameArea.canvas.width;
			  }
			  // If the player wants to move leftwards && the left extreme of their sprite is touching/beyond the left of the vancas, stop the
			  // leftward movement so they don't go off the canvas.
			  if((speedX < 0) && ((players[0].x - players[0].radius) <= 0)){
				  speedX = 0;
			  }
			  // If the player wants to move upwards && the top of their sprite is touching/beyond the top of the canvas, stop the upward movement so they don't go off the canvas.
			  if((speedY < 0) && players[0].y <= 0){
				  speedY = 0;

			  }
			  // If the player wants to move downwards && the bottom of their sprite is touching/beyond the bottom of the canvas, stop the downward movement so they don't go off the screen.
			  if((speedY > 0) && ((players[0].y + players[0].radius) >= worldHeight)){
				  speedY = 0;
			  }
			  
			  players[0].x = players[0].x + speedX;
			  players[0].y = players[0].y + speedY; 



			  topCornerX = players[0].x - myGameArea.canvas.width*.5;
			  topCornerY = players[0].y - myGameArea.canvas.height*.5;

			  /*for(i = 0; i < obstacles.length; i++)
			  {
					 // finding the distance between obstacles and the player
					 obstacleDistance = Math.pow(Math.pow(player.x - obstacles[i].x, 2) + Math.pow(player.y-obstacles[i].y, 2), 0.5);
					 
					// finding the distance between the mouse cursor and obstacles
					 cursorDistance = Math.pow(Math.pow(myGameArea.x - obstacles[i].x, 2) + Math.pow(myGameArea.y-obstacles[i].y, 2), 0.5);
					 
					 // finding the maximum distance the player and the obstacle can be close to each other without being in contact
					 // with each other
					 maxDistance = player.radius + obstacles[i].radius;
					  
					// bouncing code in theory
					if(obstacleDistance - maxDistance <= 3)
					 {
						player.x = player.x - 50;
						player.y = player.y - 50;
						speedX = speedX * -.5;
						speedY = speedY * .5;
					 }
						/*for(j = 0; j < 2; j++)
						{
						  if(j == 0)
						  {
							player.x = player.x - 50;
							player.y = player.y + 50;
						  }
						  else if(j == 1)
						  {
							player.x = player.x + 50;
							player.y = player.y - 50;

							j  = 0;
						  }
						}
					 }
			  }*/
		  }
	  }



	  function dealDamage(){
		  obstaclesDamageMonstersAndPlayers();
		  monstersAndPlayersDamageEachOther();
		  playersDamageEachOther();
	  }



	  function playersDamageEachOther(){
		  for(outer = 0; outer < (players.length-1); outer ++){
			  for(inner = (outer + 1); inner < players.length; inner++){
				  rOuter = players[outer].radius;
				  rInner = players[inner].radius;
				  if(computeDistance(players[outer], players[inner]) <= (rOuter + rInner)){
					  if(rOuter >= rInner){
						  players[outer].changeArea(monsterAndPlayerDamage);
						  players[inner].changeArea(- monsterAndPlayerDamage);
					  }
					  else{
						  players[inner].changeArea(monsterAndPlayerDamage);
						  players[outer].changeArea(- monsterAndPlayerDamage);
					  }
				  }
			  }
		  }
	  }




	  function obstaclesDamageMonstersAndPlayers(){
		  for(let monsterToDamage of monsters){
			  if(monsterToDamage.touchingObstacle()){
				  monsterToDamage.changeArea(- obstacleDamage);
			  }
		  }
		  for(let playerToDamage of players){
			  if(playerToDamage.touchingObstacle()){
				  playerToDamage.changeArea(- obstacleDamage);
			  }
		  }
	  }



	  function monstersAndPlayersDamageEachOther(){
		  for(let monsterToExamine of monsters){
			  for(playerChecker = 0; playerChecker < monsterToExamine.distances.length; playerChecker++){
				  // if monster is touching a player
				  if(monsterToExamine.distances[playerChecker] <= (monsterToExamine.radius + players[playerChecker].radius)){
					  //if monster should damage player
					  if(monsterToExamine.radius > players[playerChecker].radius){
						  monsterToExamine.changeArea(monsterAndPlayerDamage);
						  players[playerChecker].changeArea(- monsterAndPlayerDamage);
					  }
					  // if player should damage monster
					  else{
						  monsterToExamine.changeArea(- monsterAndPlayerDamage);
						  players[playerChecker].changeArea(monsterAndPlayerDamage);
					  }
				  }
			  }
		  }
	  }
		   


	  function updateIntervalCounter(){
		  // If one second has passed since the last piece of food was added...
		  if(intervalCounter == 50){
			// Although it looks like the above and below "if" loops can be combined, please do not combine
			// them, because that would slightly break the game logic.
			  if(food.length < maxAmountOfFood){
				  //...add a new food to the end of the food array...
				  newCoordinates = getNewRandomCoordinates(foodRadius);
				  var newFood = new foodPiece(newCoordinates[0], newCoordinates[1]);
				  newFood.prototype = Object.create(component.prototype);
				  food.push(newFood);
			  }
			  // ...reset the interval counter.
			  intervalCounter = 0;
		  }
		  else{
			  intervalCounter++;
		  }
	  }



	  function tryToEat(eater, foodNum){
		  // this if statement catches the case where array of food was only 1 long and the food was
		  // already eaten.
		  if(foodNum >= 0){
			  distance = computeDistance(eater, food[foodNum]);
			  /// if the sprite overlaps with the food
			  if(distance <= (eater.radius + foodRadius)){
				  eater.changeArea(growthThroughEatingFood);
				  // Remove that piece of food from the food array. The "1" parameter makes its so that only one food element will be spliced.
				  food.splice(foodNum, 1);
				  // Subtract 1 from foodNum so that foodCounter in checkFood(), the super-method, is decreased by // 1, to account for the change in indexing of all remaining food pieces after the food array
				  // is spliced.
				  return (foodNum - 1);
			  }
			  else{
				  return foodNum;
			  }
		  }
	  }




	  function drawNewFrame(){
		  myGameArea.clear();
		  for(let obstacleToUpdate of obstacles){
			// some if statement that deals with the speed of the player and deciding if depending on whether the diff speeds are positive/negative 
			// either add or subtract from the x and y of the obstacles. 
			// if(something about speed signs)
			   /* if((obstacleToUpdate.x + obstacleToUpdate.radius) >= topCornerX && (obstacleToUpdate.x + obstacleToUpdate.radius) <= (topCornerX + myGameArea.canvas.width) &&
				   (obstacleToUpdate.y + obstacleToUpdate.radius) >= topCornerY && (obstacleToUpdate.y + obstacleToUpdate.radius) <= (topCornerY + myGameArea.canvas.height))*/
				{
					obstacleToUpdate.update();
				}
			}
		  for(let foodToUpdate of food){
			  foodToUpdate.update();
		  }
		  for(let monsterToUpdate of monsters){
			  monsterToUpdate.update();
		  }
		  for(let playerToUpdate of players){
			  playerToUpdate.update();
		  }
	  }

	</script>

  </head>

  <body onload ="startGame()">
	
  </body>

</html>